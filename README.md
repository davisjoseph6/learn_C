C programming language (only, for now):
- without using C computer libraries (or atleast as minimally as possible).
- using vim editor on Ubuntu version 22.04.5 LTS or higher.
- how to write programs given at the end.

# Algebraic geometry
- Algebraic geometry
## Category theory:
- Category Theory
- Higher Category Theory 

# Computer Science & Computer Engineering

## The basics, foundations, fundamentals:
- Computational complexity theory,
- Zipper (data structure)
- Algebraic data type, 
- Information geometry
- Linear programming 
- Topos theory
- Partial differential equations
- Category theory
- Model Theory
- Optimal Control
- Program analysis
- Lexical analysis
- Maxwell's equations
- Statistical signal processing

## Projects (take your time to develop and execute):
1. binary system and x86-64 machine code. 
2. objdump disassembler and GNU assembler for x-86/64, and x86-64 assembly language. 
3. GCC’s extended inline assembly.
4. x-86-64 language implementation (front-end) which also includes a standalone compiler, in C programming language. 
5. An Algol 60 (if possible, or else Fortran) implementation (front-end) which also includes a standalone transpiler, in C.
6. A Unix shell intepreter (a simple bash clone), and a simple Linux/Unix clone.
7. MySQL Connector/C
8. A Python and CPython language implementations (front-ends) in C with standalone interpreter (with bytecodes) and Virtual Machine, in C.
9. Nvidia CUDA and compiler clone following GPGPU format, with a virtual ISA written in C.  
10. MongoDB C Driver   
11. Machine Learning and AI: A Probably approximately correct learning project. After completing it fully, move on to hosting and deploying locally first, then to Amazon Web Services (on SageMaker and Elastic Container Service), Microsoft Azure, or Digital Ocean if the first two options are unavailable.
12. Distributed computing architecture: implement a project involving pi-calculus and an actor model (computer science), in C programming language.
12. Build a mini Erlang/OTP-style actor runtime in C that compiles a small π-calculus DSL to actors/mailboxes, using libuv for async scheduling, NNG/ZeroMQ for inter-actor messaging, and Protocol Buffers for typed payloads—then demo it as a fault-tolerant distributed URL shortener with supervisor-like restarts.
12. Distributed computing architecture project involving a complete pipeline with an orchestrater (Apache Airflow), exposed via API to an UI, with Data processing, streaming and computation using CPU, CUDA, Apache Spark and Transformer architectures (AI model versioning on SageMaker), with an optional RAG, Kafka acting as the message bus and with ingestion via HTPS/SFTP to a Data Lake (HDFS/S3) on a Parquest/ORD structure. Cybersecurity features provided via, Authentication, tokenization, Single-Sign On, Secrets Vault, with lifecyle management via Promehteus and Grafana.   
13. Elliptic-curve cryptography project.

## More Topics in CS and CE:
- Graph data structure,
- Functional data structures
- buchberger’s algorithm, 
- models of computation
- Information theory
- Categorical logic
- Type theory
- Denotational semantics
- Control flow
- Data modeling
- Convex optimization
- Cybernetics
- System theory

### Higher Category Theory: 
- Higher Category Theory

### Formal logic:
- Formal logic
- Mathematical logic

## Artificial Intelligence (AI) and Machine Learning:
- Probably approximately correct (PAC) Learning
- Statistical learning theory
- Partially observable Markov decision process

### More AI:
- Neural tangent kernel,
- Mean-field theory
- Computational Learning Theory,
- Vapnik–Chervonenkis theory,
- Topological deep learning
1. Project: Deep Multi-Agent Reinforcement Learning with Partially Observable Markov Decision Process (POMDP), Using Policy Gradients and a Transformer-Based Deep Neural Network, with an Exploration/Exploitation Balance, and Deep Q-Learning.

### Even more AI
- check the README.md inside this directory for topics.

# Physics
- Quantum field theory
## More:
- Mean-field theory
- Renormalization group (QFT),
- Critical Phenomena (physics)
- Gravity (Gravitation)
### Even more:
- Statistical mechanics,
- Dynamical systems,
- Condensed Matter Physics,
- Classical field theory,
- Classical mechanics,
- Motion (physics),
- Dynamics (mechanics),
- Statics
- Metaphysics

# More
- whatever I forgot to add (or any modifications to this list/readme).

# How to write programs:

Below is the process and steps I need to follow for writing programs: 
1. Start by thinking about the question before writing code: determine what is expected, the conditions, etc. (software requirements and software design). 
2. Before writing the entire code, look for answers in the software documentation, technical communication, and manual pages, if they are accessible and available. 
3. Whiteboard (abstraction), software architecture, data modeling, write pseudocode (design pattern), then boilerplate code (if necessary). 
4. Start coding. However, before targeting all requirements, first make sure you get the expected output on the terminal. 
5. Test regularly, not only for standard cases, but also for special cases (edge cases). 
6. Try to satisfy the other conditions. Also keep in mind the principle of separation of concerns (modular programming). 
7. Write unit tests whenever possible. 
8. Restructure (refactor) your code. 
9. The, optimize it to make it more efficient, run faster, and use less space or memory (time and space complexity). 
10. Once this is done, you can continue by fulfilling the other requirements, such as coding style, comments, best practices, etc

# Author:
- Davis Joseph (github: davisjoseph6)
- with help from Denis Joseph
