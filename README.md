C programming language (only, for now):
- without using C libraries
- using vim editor on Ubuntu version 22.04.5 LTS or higher.
- how to write programs given at the end.

# Algebraic geometry
- Algebraic geometry
## Category theory:
- Category Theory
- Higher Category Theory 

# Computer Science & Computer Engineering

## The basics, foundations, fundamentals:
- Computational complexity theory,
- Zipper (data structure)
- Algebraic data type, 
- Information geometry 
- Convex optimization 
- Topos theory
- Partial differential equations
- Category theory
- Model Theory
- Optimal Control
- Program analysis
- Lexical analysis
- Maxwell's equations
- Statistical signal processing

## Projects (take your time to develop and execute):
1. binary system and x86-64 machine code. 
2. objdump disassembler and GNU assembler for x-86/64, and x86-64 assembly language. 
3. GCC’s extended inline assembly.
4. x-86-64 language implementation (front-end) which also includes a standalone compiler, in C programming language. 
5. An Algol 60 (if possible, or else Fortran) implementation (front-end) which also includes a standalone transpiler, in C.
6. A Unix shell intepreter (a simple bash clone), and a simple Linux/Unix clone.
7. MySQL Connector/C
8. A Python and CPython language implementations (front-ends) in C with standalone interpreter (with bytecodes) and Virtual Machine, in C.
9. CUDA clone following GPGPU format, with a virtual ISA written in C.  
10. MongoDB C Driver   
11. Machine Learning and AI: A Probably approximately correct learning project. After completing it fully, move on to hosting and deploying it on Amazon Web Services, Microsoft Azure, or Digital Ocean if the first two options are unavailable.


## More Topics in CS and CE:
- Graph data structure,
- Functional data structures
- buchberger’s algorithm, 
- models of computation
- Information theory
- Categorical logic
- Type theory
- Denotational semantics
- Control flow
- Data modeling

### Higher Category Theory: 
- Higher Category Theory

### Formal logic:
- Formal logic
- Mathematical logic

## Artificial Intelligence (AI) and Machine Learning:
- Probably approximately correct (PAC) Learning
- Statistical learning theory
- Partially observable Markov decision process

### More AI:
- Neural tangent kernel,
- Mean-field theory
- Computational Learning Theory,
- Vapnik–Chervonenkis theory,
- Topological deep learning
1. Project: Deep Multi-Agent Reinforcement Learning with Partially Observable Markov Decision Process (POMDP), Using Policy Gradients and a Transformer-Based Deep Neural Network, with an Exploration/Exploitation Balance, and Deep Q-Learning.

### Even more AI
- check the README.md inside this directory for topics.

# Physics
- Quantum field theory
## More:
- Mean-field theory
- Renormalization group (QFT),
- Critical Phenomena (physics)
- Gravity (Gravitation)
### Even more:
- Statistical mechanics,
- Dynamical systems,
- Condensed Matter Physics,
- Classical field theory,
- Classical mechanics,
- Motion (physics),
- Dynamics (mechanics),
- Statics
- Metaphysics

# More
- whatever I forgot to add (or any modifications to this list/readme).

# How to write programs:

Below is the process and steps I need to follow for writing programs: 
1. Start by thinking about the question before writing code: determine what is expected, the conditions, etc. (software requirements and software design). 
2. Before writing the entire code, look for answers in the software documentation, technical communication, and manual pages, if they are accessible and available. 
3. Whiteboard (abstraction), software architecture, data modeling, write pseudocode (design pattern), then boilerplate code (if necessary). 
4. Start coding. However, before targeting all requirements, first make sure you get the expected output on the terminal. 
5. Test regularly, not only for standard cases, but also for special cases (edge cases). 
6. Try to satisfy the other conditions. Also keep in mind the principle of separation of concerns (modular programming). 
7. Write unit tests whenever possible. 
8. Restructure (refactor) your code. 
9. The, optimize it to make it more efficient, run faster, and use less space or memory (time and space complexity). 
10. Once this is done, you can continue by fulfilling the other requirements, such as coding style, comments, best practices, etc

# Author:
- Davis Joseph (github: davisjoseph6)
- with help from Denis Joseph
